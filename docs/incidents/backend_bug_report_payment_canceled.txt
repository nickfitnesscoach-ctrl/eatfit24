=============================================================================
BACKEND BUG REPORT: payment.canceled FOR UPDATE error
=============================================================================

Generated: 2026-01-14 11:30:00 UTC
DevOps Agent: Production Server eatfit24.ru

=============================================================================
SUMMARY
=============================================================================

Bug: Django ORM query with select_for_update() + select_related() on
     nullable ForeignKey causes PostgreSQL error.

Error: "FOR UPDATE cannot be applied to the nullable side of an outer join"

Impact: payment.canceled webhooks cannot be processed
        → Stuck in retry loop (5 attempts with exponential backoff)
        → Eventually FAILED status
        → Repeated Telegram alerts every 15 min for 1+ hour

Event Type: payment.canceled
Handler: apps/billing/webhooks/handlers.py::_handle_payment_canceled()
Line: 257-261

=============================================================================
ROOT CAUSE
=============================================================================

File: backend/apps/billing/webhooks/handlers.py
Lines: 257-261

    payment = (
        Payment.objects.select_for_update()      # FOR UPDATE lock
        .select_related("subscription")          # LEFT OUTER JOIN (subscription is nullable)
        .get(yookassa_payment_id=yk_payment_id)
    )

PostgreSQL constraint:
  - select_related("subscription") → LEFT OUTER JOIN (because subscription FK is nullable)
  - select_for_update() → FOR UPDATE clause
  - PostgreSQL does NOT allow FOR UPDATE on nullable side of OUTER JOIN

Model constraint (apps/billing/models.py:306-313):
    subscription = models.ForeignKey(
        Subscription,
        on_delete=models.SET_NULL,
        null=True,          # <-- nullable
        blank=True,
    )

=============================================================================
AFFECTED WEBHOOKS (PRODUCTION DATA)
=============================================================================

Total failed webhooks (last 24h): 2
Event type: payment.canceled
Status: FAILED (exhausted 5 retries)

Webhook 1:
  - ID: 0fb12e1d-0e9c-4964-9e69-4611cfe0d7a2
  - trace_id: ac92cead
  - payment_id: 30f8c80c-000f-5000-b000-175b519519f5
  - created_at: 2026-01-13 22:10:29 UTC
  - attempts: 1 (DB record), 5 retries (Celery task level)
  - max_retries_reached: 2026-01-14 01:25:59 UTC

Webhook 2:
  - ID: ed7f7c05-35cf-4dc6-bd11-25d11507d182
  - trace_id: 5903abd9
  - payment_id: 30f8c9db-000f-5001-8000-1510b47b7678
  - created_at: 2026-01-13 22:18:12 UTC
  - attempts: 1 (DB record), 5 retries (Celery task level)
  - max_retries_reached: 2026-01-14 01:33:42 UTC

Retry timeline (exponential backoff):
  retry 0: immediate
  retry 1: +30s
  retry 2: +60s (total +90s)
  retry 3: +120s (total +210s)
  retry 4: +240s (total +450s)
  retry 5: +480s (total +930s = ~15.5 min)
  EXHAUSTED: logged "WEBHOOK_TASK_EXHAUSTED"

=============================================================================
FULL TRACEBACK (from production logs)
=============================================================================

[2026-01-14 01:10:29,466: ERROR/ForkPoolWorker-1] [WEBHOOK_TASK_DONE] trace_id=ac92cead log_id=0fb12e1d-0e9c-4964-9e69-4611cfe0d7a2 task_id=758fc647-d1fe-479d-9b5b-b10f55cf6b28 event=payment.canceled ok=false error=FOR UPDATE cannot be applied to the nullable side of an outer join
 retry=0/5
Traceback (most recent call last):
  File "/app/.venv/lib/python3.12/site-packages/django/db/backends/utils.py", line 105, in _execute
    return self.cursor.execute(sql, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
psycopg2.errors.FeatureNotSupported: FOR UPDATE cannot be applied to the nullable side of an outer join


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/app/apps/billing/webhooks/tasks.py", line 76, in process_yookassa_webhook
    handle_yookassa_event(event_type=event_type, payload=payload, trace_id=trace_id)
  File "/app/apps/billing/webhooks/handlers.py", line 72, in handle_yookassa_event
    handler(payload, trace_id=trace_id)
  File "/app/apps/billing/webhooks/handlers.py", line 260, in _handle_payment_canceled
    .get(yookassa_payment_id=yk_payment_id)
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/.venv/lib/python3.12/site-packages/django/db/models/query.py", line 635, in get
    num = len(clone)
          ^^^^^^^^^^
  File "/app/.venv/lib/python3.12/site-packages/django/db/models/query.py", line 372, in __len__
    self._fetch_all()
  File "/app/.venv/lib/python3.12/site-packages/django/db/models/query.py", line 2000, in _fetch_all
    self._result_cache = list(self._iterable_class(self))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/.venv/lib/python3.12/site-packages/django/db/models/query.py\", line 95, in __iter__
    results = compiler.execute_sql(
              ^^^^^^^^^^^^^^^^^^^^^
  File "/app/.venv/lib/python3.12/site-packages/django/db/models/sql/compiler.py", line 1624, in execute_sql
    cursor.execute(sql, params)
  File "/app/.venv/lib/python3.12/site-packages/django/db/backends/utils.py", line 79, in execute
    return self._execute_with_wrappers(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/.venv/lib/python3.12/site-packages/django/db/backends/utils.py", line 92, in _execute_with_wrappers
    return executor(sql, params, many, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/.venv/lib/python3.12/site-packages/django/db/backends/utils.py", line 100, in _execute
    with self.db.wrap_database_errors:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/.venv/lib/python3.12/site-packages/django/db/utils.py", line 94, in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
  File "/app/.venv/lib/python3.12/site-packages/django/db/backends/utils.py", line 105, in _execute
    return self.cursor.execute(sql, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django.db.utils.NotSupportedError: FOR UPDATE cannot be applied to the nullable side of an outer join

=============================================================================
CELERY RETRY CONFIGURATION (CURRENT)
=============================================================================

Task: apps.billing.webhooks.tasks.process_yookassa_webhook
File: backend/apps/billing/webhooks/tasks.py

@shared_task(
    bind=True,
    max_retries=5,                # 5 retry attempts
    default_retry_delay=30,       # 30 seconds base delay
    ack_late=True,
    queue="billing",
)

Backoff formula (line 113):
    delay = self.default_retry_delay * (2 ** self.request.retries)
    → 30, 60, 120, 240, 480 seconds

=============================================================================
ALERT SPAM TIMELINE
=============================================================================

Alert task: apps.billing.webhooks.tasks.alert_failed_webhooks
Schedule: Every 15 minutes (Celery Beat)
Window: Last 1 hour (checks processed_at field)

Spam occurred:
  01:15 UTC → sent alert for 1 failed webhook
  01:30 UTC → sent alert for 2 failed webhooks
  01:45 UTC → sent alert for 2 failed webhooks
  02:00 UTC → sent alert for 2 failed webhooks
  02:15 UTC → sent alert for 2 failed webhooks
  02:30 UTC → sent alert for 1 failed webhook
  02:45 UTC → no alert (processed_at outside 1h window)

Total spam: 6 alerts over 75 minutes

Alert logic (backend/apps/billing/webhooks/tasks.py:220-244):
    since = timezone.now() - timedelta(hours=1)
    failed = WebhookLog.objects.filter(
        status="FAILED",
        processed_at__gte=since  # <-- Checks last 1 hour
    )

Issue: Once FAILED records drop out of 1h window, alerts stop.
       BUT: if new payment.canceled comes in → spam resumes.

=============================================================================
PROPOSED FIX (for backend team)
=============================================================================

Option 1 (RECOMMENDED): Remove select_related if subscription not needed in lock

    payment = (
        Payment.objects
        .select_for_update()
        .get(yookassa_payment_id=yk_payment_id)
    )

    # Access subscription AFTER lock (separate query if needed)
    if payment.subscription:
        subscription = payment.subscription
        # ... handle recurring cancellation

Option 2: Use select_related ONLY if subscription exists (conditional)

    payment = Payment.objects.select_for_update().get(
        yookassa_payment_id=yk_payment_id
    )

    if payment.is_recurring and payment.subscription_id:
        # Refetch with subscription if needed
        payment = Payment.objects.select_related("subscription").get(
            pk=payment.pk
        )

Option 3: Use only() / defer() to avoid JOIN but keep FK reference

    payment = (
        Payment.objects
        .select_for_update()
        .only("id", "status", "subscription_id", ...)
        .get(yookassa_payment_id=yk_payment_id)
    )

=============================================================================
DEVOPS MITIGATION STATUS
=============================================================================

Current state: NO ACTIVE SPAM (as of 2026-01-14 11:00 UTC)
Reason: FAILED webhooks processed_at > 1 hour ago
Risk: If new payment.canceled arrives → spam resumes

DevOps action taken: NONE REQUIRED NOW
Recommendation: Backend fix ASAP, then retry failed webhooks manually

Manual retry procedure (after backend fix is deployed):
    1. Deploy backend fix
    2. Reset failed webhooks to QUEUED:

       UPDATE webhook_logs
       SET status = 'QUEUED', error_message = 'Manual retry after FOR UPDATE fix'
       WHERE status = 'FAILED' AND event_type = 'payment.canceled';

    3. Requeue Celery tasks:

       docker exec eatfit24-backend-1 python manage.py shell -c "
       from apps.billing.webhooks.tasks import process_yookassa_webhook
       from apps.billing.models import WebhookLog
       for log in WebhookLog.objects.filter(status='QUEUED'):
           process_yookassa_webhook.delay(str(log.id))
       "

=============================================================================
ALERT ANTI-SPAM IMPROVEMENT (OPTIONAL)
=============================================================================

Current behavior: Alerts repeat every 15 min while FAILED records in 1h window
Better behavior: Alert ONCE per unique error, then silence until new failure

Proposed change (backend/apps/billing/webhooks/tasks.py):

    # Store last alerted webhook IDs in Redis with 1h TTL
    # Only alert if new FAILED webhooks appear

    from django.core.cache import cache

    ALERT_CACHE_KEY = "billing:last_alerted_webhooks"

    last_alerted = cache.get(ALERT_CACHE_KEY, set())
    new_failures = failed.exclude(id__in=last_alerted)

    if new_failures.exists():
        # Send alert only for NEW failures
        _send_telegram_alert(...)

        # Update cache with all current failed IDs
        cache.set(ALERT_CACHE_KEY, set(failed.values_list('id', flat=True)), 3600)

=============================================================================
END OF REPORT
=============================================================================
